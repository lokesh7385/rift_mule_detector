/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MuleWatch â€” Dashboard Application Logic
   Financial Crime Detection Frontend
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

(() => {
    'use strict';

    // â”€â”€â”€ State â”€â”€â”€
    let analysisData = null;
    let cy = null;
    let activeFilter = 'all';

    // â”€â”€â”€ DOM Refs â”€â”€â”€
    const sidebar = document.getElementById('sidebar');
    const mainContent = document.getElementById('main-content');
    const fileInput = document.getElementById('file-input');
    const uploadOverlay = document.getElementById('upload-overlay');
    const loadingOverlay = document.getElementById('loading-overlay');
    const uploadCard = uploadOverlay.querySelector('.upload-card');
    const sidebarUploadBtn = document.getElementById('sidebar-upload-btn');
    const uploadBrowseBtn = document.getElementById('upload-browse-btn');

    // Metrics
    const valTransactions = document.getElementById('val-transactions');
    const valRings = document.getElementById('val-rings');
    const valHighRisk = document.getElementById('val-highrisk');
    const valTime = document.getElementById('val-time');

    // Sections
    const graphSection = document.querySelector('.graph-section');
    const tableSection = document.querySelector('.table-section');
    const settingsSection = document.querySelector('.settings-section');
    const allSections = [graphSection, tableSection, settingsSection];

    // Action Panel
    const actionPanel = document.getElementById('action-panel');
    const panelClose = document.getElementById('panel-close');
    const panelAccountId = document.getElementById('panel-account-id');
    const panelAvatar = document.getElementById('panel-avatar');
    const panelStatus = document.getElementById('panel-status');
    const panelGauge = document.getElementById('panel-gauge');
    const panelScore = document.getElementById('panel-score');
    const panelRiskLabel = document.getElementById('panel-risk-label');
    const panelInDegree = document.getElementById('panel-in-degree');
    const panelOutDegree = document.getElementById('panel-out-degree');
    const panelRingsCount = document.getElementById('panel-rings-count');
    const panelPatternsCount = document.getElementById('panel-patterns-count');
    const panelPatterns = document.getElementById('panel-patterns');
    const panelTimeline = document.getElementById('panel-timeline');
    const btnFreeze = document.getElementById('btn-freeze');
    const btnFlag = document.getElementById('btn-flag');
    const btnDownload = document.getElementById('btn-download');
    const btnReset = document.getElementById('btn-reset');
    const btnFullReport = document.getElementById('btn-full-report');

    // Toast
    const toast = document.getElementById('toast');

    // Nav links
    const navLinks = document.querySelectorAll('.nav-link');

    // Ring colors
    const RING_COLORS = [
        '#FF3131', '#FF6B35', '#FFAA00', '#39FF14',
        '#00A3FF', '#7C3AED', '#EC4899', '#14B8A6',
        '#F97316', '#6366F1', '#84CC16', '#E11D48',
    ];

    function getRingColor(ringId) {
        if (!ringId) return '#4a5568';
        const num = parseInt(ringId.replace(/\D/g, ''), 10) || 0;
        return RING_COLORS[num % RING_COLORS.length];
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SIDEBAR NAVIGATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    navLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const section = link.dataset.section;

            // Update active state
            navLinks.forEach(l => l.classList.remove('active'));
            link.classList.add('active');

            // Show/hide sections
            if (section === 'overview') {
                // Scroll to top
                mainContent.scrollTo({ top: 0, behavior: 'smooth' });
            } else if (section === 'network-analysis' && analysisData) {
                scrollToElement(graphSection);
            } else if (section === 'risk-reports' && analysisData) {
                scrollToElement(tableSection);
            } else if (section === 'settings') {
                showSection('settings');
            }
        });
    });

    function scrollToElement(el) {
        if (el && !el.classList.contains('hidden')) {
            el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    function showSection(name) {
        if (name === 'settings') {
            settingsSection.classList.toggle('hidden');
            if (!settingsSection.classList.contains('hidden')) {
                scrollToElement(settingsSection);
            }
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FILE UPLOAD
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Sidebar upload button
    sidebarUploadBtn.addEventListener('click', () => fileInput.click());

    // Browse button in overlay
    uploadBrowseBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        fileInput.click();
    });

    // Click on the upload card
    uploadCard.addEventListener('click', () => fileInput.click());

    // Drag & Drop on the upload card
    uploadCard.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadCard.classList.add('drag-over');
    });

    uploadCard.addEventListener('dragleave', () => {
        uploadCard.classList.remove('drag-over');
    });

    uploadCard.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadCard.classList.remove('drag-over');
        const file = e.dataTransfer.files[0];
        if (file && file.name.toLowerCase().endsWith('.csv')) {
            processFile(file);
        } else {
            showToast('Please upload a .csv file', 'error');
        }
    });

    // File input change
    fileInput.addEventListener('change', () => {
        if (fileInput.files.length > 0) {
            processFile(fileInput.files[0]);
        }
    });

    async function processFile(file) {
        // Show loading
        uploadOverlay.classList.add('hidden');
        loadingOverlay.classList.remove('hidden');

        const CHUNK_THRESHOLD = 10 * 1024 * 1024; // 10 MB

        if (file.size <= CHUNK_THRESHOLD) {
            // â”€â”€ SMALL FILE: Direct upload (no chunking) â”€â”€
            await uploadDirect(file);
        } else {
            // â”€â”€ LARGE FILE: Chunked upload â”€â”€
            await uploadChunked(file);
        }
    }

    async function uploadDirect(file) {
        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error || 'Upload failed');
            }

            analysisData = await response.json();
            loadingOverlay.classList.add('hidden');
            renderDashboard();
            showToast('Analysis complete â€” fraud rings detected!', 'success');
        } catch (err) {
            loadingOverlay.classList.add('hidden');
            uploadOverlay.classList.remove('hidden');
            showToast('Error: ' + err.message, 'error');
        }
    }

    async function uploadChunked(file) {
        const CHUNK_SIZE = 2 * 1024 * 1024; // 2 MB
        const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
        let fileId = null;

        for (let i = 0; i < totalChunks; i++) {
            const start = i * CHUNK_SIZE;
            const end = Math.min(start + CHUNK_SIZE, file.size);
            const chunk = file.slice(start, end);

            const formData = new FormData();
            formData.append('file', chunk, file.name);
            formData.append('chunkIndex', i);
            formData.append('totalChunks', totalChunks);
            if (fileId) formData.append('fileId', fileId);

            try {
                const percent = Math.round(((i + 1) / totalChunks) * 100);
                const loadingSub = document.querySelector('.loading-sub');
                const progressFill = document.querySelector('.scan-progress-fill');

                if (loadingSub) loadingSub.textContent = `Uploading part ${i + 1}/${totalChunks} (${percent}%)...`;
                if (progressFill) progressFill.style.width = `${percent}%`;

                const response = await fetch('/upload_chunk', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || 'Upload failed');
                }

                const data = await response.json();

                if (i === 0) {
                    fileId = data.file_id;
                    analysisData = data;
                    loadingOverlay.classList.add('hidden');
                    renderDashboard();
                    showToast('Initial analysis ready! Uploading remainder in background...', 'info');
                }
                else if (i === totalChunks - 1) {
                    showToast('Upload complete. Background analysis running.', 'success');
                }

            } catch (err) {
                loadingOverlay.classList.add('hidden');
                if (!analysisData) {
                    uploadOverlay.classList.remove('hidden');
                }
                showToast('Error: ' + err.message, 'error');
                return;
            }
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RENDER DASHBOARD
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function renderDashboard() {
        const s = analysisData.summary;

        // Enable buttons
        btnDownload.disabled = false;
        btnReset.disabled = false;

        // Handle Full Report Button
        if (analysisData.is_partial) {
            btnFullReport.classList.remove('hidden');
            btnFullReport.disabled = false;
            if (!btnFullReport.innerHTML.includes('View Full Report')) {
                btnFullReport.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="12" y1="18" x2="12" y2="12"/>
                        <line x1="9" y1="15" x2="15" y2="15"/>
                    </svg>
                    View Full Report
                `;
            }
        } else {
            btnFullReport.classList.add('hidden');
        }

        // Populate metrics
        animateCounter(valTransactions, s.total_accounts_analyzed);
        animateCounter(valRings, s.fraud_rings_detected);
        animateCounter(valHighRisk, s.suspicious_accounts_flagged);
        valTime.textContent = s.processing_time_seconds + 's';

        // Show graph and tables
        graphSection.classList.remove('hidden');
        tableSection.classList.remove('hidden');

        // Render components
        renderGraph();
        renderDetectionTable();
        renderRingsTable();
    }

    function animateCounter(el, target) {
        let current = 0;
        const duration = 800;
        const startTime = performance.now();

        function tick(now) {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3); // ease out cubic
            current = Math.round(eased * target);
            el.textContent = current;
            if (progress < 1) {
                requestAnimationFrame(tick);
            }
        }
        requestAnimationFrame(tick);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // NETWORK GRAPH
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function renderGraph() {
        const { nodes, edges } = analysisData.graph;

        // Ring color map
        const ringColorMap = {};
        analysisData.fraud_rings.forEach(ring => {
            ringColorMap[ring.ring_id] = getRingColor(ring.ring_id);
        });

        // Build fraud ring membership set
        const fraudRingMembers = new Set();
        analysisData.fraud_rings.forEach(ring => {
            ring.member_accounts.forEach(a => fraudRingMembers.add(a));
        });

        // Prepare Cytoscape elements
        const elements = [];

        nodes.forEach(n => {
            let color = '#3a3a52';
            let borderColor = '#2a2a3a';
            let borderWidth = 2;
            let size = 28;

            if (n.suspicious) {
                const primaryRing = n.ring_ids[0];
                color = primaryRing ? ringColorMap[primaryRing] || '#FFAA00' : '#FFAA00';
                borderColor = 'rgba(255,255,255,0.6)';
                borderWidth = 2.5;
                size = 32 + Math.min(n.score, 100) * 0.2;
            }

            elements.push({
                data: {
                    id: n.id,
                    label: n.id,
                    color,
                    borderColor,
                    borderWidth,
                    size,
                    suspicious: n.suspicious,
                    score: n.score,
                    ring_ids: n.ring_ids,
                    in_degree: n.in_degree,
                    out_degree: n.out_degree,
                },
            });
        });

        edges.forEach(e => {
            // Determine if this edge is between fraud ring members
            const isFraudEdge = fraudRingMembers.has(e.source) && fraudRingMembers.has(e.target);
            elements.push({
                data: {
                    source: e.source,
                    target: e.target,
                    amount: e.total_amount,
                    count: e.count,
                    label: '$' + e.total_amount.toLocaleString(),
                    isFraud: isFraudEdge,
                },
            });
        });

        cy = cytoscape({
            container: document.getElementById('cy'),
            elements,
            style: [
                {
                    selector: 'node',
                    style: {
                        'background-color': 'data(color)',
                        'border-color': 'data(borderColor)',
                        'border-width': 'data(borderWidth)',
                        'label': 'data(label)',
                        'width': 'data(size)',
                        'height': 'data(size)',
                        'font-size': '8px',
                        'font-family': "'JetBrains Mono', monospace",
                        'color': '#888',
                        'text-valign': 'bottom',
                        'text-margin-y': 7,
                        'text-outline-color': '#0d0d14',
                        'text-outline-width': 2,
                        'transition-property': 'background-color, border-color, width, height, opacity',
                        'transition-duration': '0.25s',
                    },
                },
                {
                    selector: 'node[?suspicious]',
                    style: {
                        'shadow-blur': 18,
                        'shadow-color': 'data(color)',
                        'shadow-opacity': 0.6,
                        'shadow-offset-x': 0,
                        'shadow-offset-y': 0,
                        'font-weight': 'bold',
                        'font-size': '9px',
                        'color': '#bbb',
                    },
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 1.5,
                        'line-color': '#1e1e30',
                        'target-arrow-color': '#3a3a52',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                        'arrow-scale': 1,
                        'label': 'data(label)',
                        'font-size': '6px',
                        'color': '#44445a',
                        'text-outline-color': '#0d0d14',
                        'text-outline-width': 1.5,
                        'text-rotation': 'autorotate',
                        'opacity': 0.5,
                    },
                },
                {
                    selector: 'edge[?isFraud]',
                    style: {
                        'line-color': 'rgba(255, 49, 49, 0.4)',
                        'target-arrow-color': 'rgba(255, 49, 49, 0.6)',
                        'width': 2.5,
                        'opacity': 0.8,
                    },
                },
                {
                    selector: 'node.highlighted',
                    style: {
                        'border-color': '#00A3FF',
                        'border-width': 4,
                        'shadow-blur': 30,
                        'shadow-color': '#00A3FF',
                        'shadow-opacity': 0.8,
                    },
                },
                {
                    selector: 'edge.highlighted',
                    style: {
                        'line-color': '#00A3FF',
                        'target-arrow-color': '#00A3FF',
                        'width': 3,
                        'opacity': 1,
                    },
                },
                {
                    selector: 'node.dimmed',
                    style: {
                        'opacity': 0.12,
                    },
                },
                {
                    selector: 'edge.dimmed',
                    style: {
                        'opacity': 0.04,
                    },
                },
                {
                    selector: 'node.selected-node',
                    style: {
                        'border-color': '#00A3FF',
                        'border-width': 5,
                        'shadow-blur': 35,
                        'shadow-color': '#00A3FF',
                        'shadow-opacity': 1,
                    },
                },
            ],
            layout: {
                name: 'cose',
                animate: true,
                animationDuration: 1200,
                nodeRepulsion: () => 9000,
                idealEdgeLength: () => 130,
                gravity: 0.25,
                padding: 50,
                fit: true,
            },
            minZoom: 0.3,
            maxZoom: 3,
        });

        // â”€â”€â”€ Node tap â†’ Open Action Panel â”€â”€â”€
        cy.on('tap', 'node', (evt) => {
            const node = evt.target;
            const d = node.data();

            // Highlight the clicked node and its ring
            cy.elements().removeClass('highlighted dimmed selected-node');

            if (d.ring_ids && d.ring_ids.length > 0) {
                const ringMembers = new Set();
                d.ring_ids.forEach(rid => {
                    const ring = analysisData.fraud_rings.find(r => r.ring_id === rid);
                    if (ring) ring.member_accounts.forEach(a => ringMembers.add(a));
                });

                cy.elements().addClass('dimmed');
                ringMembers.forEach(accId => {
                    const n = cy.getElementById(accId);
                    if (n.length) {
                        n.removeClass('dimmed').addClass('highlighted');
                        n.connectedEdges().forEach(edge => {
                            const src = edge.source().id();
                            const tgt = edge.target().id();
                            if (ringMembers.has(src) && ringMembers.has(tgt)) {
                                edge.removeClass('dimmed').addClass('highlighted');
                            }
                        });
                    }
                });
            }

            node.addClass('selected-node');
            openActionPanel(d);
        });

        // Click background â†’ Close panel, reset highlights
        cy.on('tap', (evt) => {
            if (evt.target === cy) {
                cy.elements().removeClass('highlighted dimmed selected-node');
                closeActionPanel();
            }
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ACTION PANEL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function openActionPanel(nodeData) {
        const d = nodeData;
        actionPanel.classList.add('open');
        mainContent.classList.add('panel-open');

        // Account info
        panelAccountId.textContent = d.id;
        panelAvatar.textContent = d.id.substring(0, 2);

        // Status
        const isSuspicious = d.suspicious;
        panelStatus.textContent = isSuspicious ? 'âš  Suspicious Account' : 'âœ“ Clean Account';
        panelStatus.style.color = isSuspicious ? '#FF3131' : '#39FF14';

        // Risk gauge
        const score = d.score || 0;
        panelScore.textContent = score;
        panelGauge.style.width = score + '%';
        panelGauge.className = 'gauge-fill';

        if (score >= 70) {
            panelGauge.classList.add('high');
            panelRiskLabel.textContent = 'Critical';
            panelRiskLabel.className = 'gauge-label high';
        } else if (score >= 40) {
            panelGauge.classList.add('medium');
            panelRiskLabel.textContent = 'Medium';
            panelRiskLabel.className = 'gauge-label medium';
        } else {
            panelRiskLabel.textContent = 'Low';
            panelRiskLabel.className = 'gauge-label low';
        }

        // Stats
        panelInDegree.textContent = d.in_degree || 0;
        panelOutDegree.textContent = d.out_degree || 0;
        panelRingsCount.textContent = d.ring_ids ? d.ring_ids.length : 0;

        // Patterns
        const acct = analysisData.suspicious_accounts.find(a => a.account_id === d.id);
        const patterns = acct ? acct.detected_patterns : [];
        panelPatternsCount.textContent = patterns.length;

        if (patterns.length > 0) {
            panelPatterns.innerHTML = patterns.map(p => {
                const isHighRisk = p.includes('cycle') || p.includes('high_velocity');
                return `<span class="pattern-chip ${isHighRisk ? '' : 'info'}">${formatPatternName(p)}</span>`;
            }).join('');
        } else {
            panelPatterns.innerHTML = '<span class="empty-state">No patterns detected</span>';
        }

        // Transaction Timeline (build from graph edges)
        buildTimeline(d.id);

        // Enable action buttons
        btnFreeze.disabled = !isSuspicious;
        btnFlag.disabled = false;
    }

    function closeActionPanel() {
        actionPanel.classList.remove('open');
        mainContent.classList.remove('panel-open');
    }

    panelClose.addEventListener('click', () => {
        closeActionPanel();
        if (cy) cy.elements().removeClass('highlighted dimmed selected-node');
    });

    function buildTimeline(accountId) {
        if (!analysisData || !analysisData.graph) {
            panelTimeline.innerHTML = '<span class="empty-state">No transaction data</span>';
            return;
        }

        const { edges } = analysisData.graph;
        const relatedEdges = edges.filter(e => e.source === accountId || e.target === accountId);

        if (relatedEdges.length === 0) {
            panelTimeline.innerHTML = '<span class="empty-state">No transaction data</span>';
            return;
        }

        // Sort by amount (we don't have timestamps in graph edges, so we'll use amount as a proxy)
        const sorted = [...relatedEdges].sort((a, b) => b.total_amount - a.total_amount);
        const shown = sorted.slice(0, 8);

        panelTimeline.innerHTML = shown.map(edge => {
            const isOutgoing = edge.source === accountId;
            const peer = isOutgoing ? edge.target : edge.source;
            const direction = isOutgoing ? 'Sent to' : 'Received from';

            return `
                <div class="timeline-item">
                    <div class="timeline-dot ${isOutgoing ? 'outgoing' : ''}"></div>
                    <div class="timeline-info">
                        <div class="timeline-amount">${isOutgoing ? '-' : '+'}$${edge.total_amount.toLocaleString()}</div>
                        <div class="timeline-detail">${direction} <strong>${peer}</strong> Â· ${edge.count} txn(s)</div>
                    </div>
                </div>
            `;
        }).join('');
    }

    function formatPatternName(pattern) {
        return pattern
            .replace(/_/g, ' ')
            .replace(/\b\w/g, c => c.toUpperCase());
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DETECTION TABLE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function renderDetectionTable(filter = 'all') {
        const tbody = document.getElementById('detection-tbody');
        tbody.innerHTML = '';

        let accounts = analysisData.suspicious_accounts;

        // Filter
        if (filter === 'high') {
            accounts = accounts.filter(a => a.suspicion_score >= 70);
        } else if (filter === 'medium') {
            accounts = accounts.filter(a => a.suspicion_score >= 40 && a.suspicion_score < 70);
        } else if (filter === 'low') {
            accounts = accounts.filter(a => a.suspicion_score < 40);
        }

        accounts.forEach(acct => {
            const tr = document.createElement('tr');

            // Score badge class
            let scoreClass = 'score-low';
            if (acct.suspicion_score >= 70) scoreClass = 'score-critical';
            else if (acct.suspicion_score >= 50) scoreClass = 'score-high';
            else if (acct.suspicion_score >= 30) scoreClass = 'score-medium';

            // Pattern tags
            const patterns = acct.detected_patterns
                .map(p => `<span class="pattern-tag">${formatPatternName(p)}</span>`)
                .join(' ');

            // Simulated last activity (based on current time)
            const minutesAgo = Math.floor(Math.random() * 120) + 5;
            const lastActivity = minutesAgo < 60 ? `${minutesAgo}m ago` : `${Math.floor(minutesAgo / 60)}h ${minutesAgo % 60}m ago`;

            tr.innerHTML = `
                <td><span style="color: var(--text-primary); font-weight: 600;">${acct.account_id}</span></td>
                <td><span class="score-badge ${scoreClass}">${acct.suspicion_score}</span></td>
                <td>${patterns}</td>
                <td><span class="ring-id-tag" style="color:${getRingColor(acct.ring_id)}">${acct.ring_id}</span></td>
                <td style="color: var(--text-muted)">${lastActivity}</td>
            `;

            // Click row â†’ highlight node in graph
            tr.addEventListener('click', () => {
                if (cy) {
                    const node = cy.getElementById(acct.account_id);
                    if (node.length) {
                        cy.animate({ center: { eles: node }, zoom: 1.5 }, { duration: 500 });
                        node.emit('tap');
                    }
                }
            });

            tbody.appendChild(tr);
        });

        if (accounts.length === 0) {
            tbody.innerHTML = `<tr><td colspan="5" style="text-align:center; color:var(--text-muted); padding:32px;">No accounts match this filter</td></tr>`;
        }
    }

    // Filter buttons
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            activeFilter = btn.dataset.filter;
            if (analysisData) renderDetectionTable(activeFilter);
        });
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FRAUD RINGS TABLE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function renderRingsTable() {
        const tbody = document.getElementById('rings-tbody');
        tbody.innerHTML = '';

        analysisData.fraud_rings.forEach(ring => {
            const tr = document.createElement('tr');

            let scoreClass = 'score-low';
            if (ring.risk_score >= 70) scoreClass = 'score-critical';
            else if (ring.risk_score >= 50) scoreClass = 'score-high';
            else if (ring.risk_score >= 30) scoreClass = 'score-medium';

            tr.innerHTML = `
                <td><span style="color:${getRingColor(ring.ring_id)}; font-weight:800;">${ring.ring_id}</span></td>
                <td><span class="pattern-tag">${formatPatternName(ring.pattern_type)}</span></td>
                <td>${ring.member_accounts.length}</td>
                <td><span class="score-badge ${scoreClass}">${ring.risk_score}</span></td>
                <td style="font-size:0.72rem; max-width:340px; word-break:break-all; color:var(--text-muted);">${ring.member_accounts.join(', ')}</td>
            `;
            tbody.appendChild(tr);
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FREEZE / FLAG / DOWNLOAD / RESET
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    btnFreeze.addEventListener('click', async () => {
        const accountId = panelAccountId.textContent;
        if (!accountId || accountId === 'â€”') return;

        try {
            const response = await fetch('/freeze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ account_id: accountId }),
            });
            const data = await response.json();
            showToast(`Account ${accountId} has been frozen`, 'success');
            btnFreeze.disabled = true;
            btnFreeze.textContent = 'ðŸ”’ Account Frozen';
            panelStatus.textContent = 'ðŸ”’ Account Frozen';
            panelStatus.style.color = '#FFAA00';
        } catch (err) {
            showToast('Failed to freeze account: ' + err.message, 'error');
        }
    });

    btnFlag.addEventListener('click', () => {
        const accountId = panelAccountId.textContent;
        if (!accountId || accountId === 'â€”') return;
        showToast(`Account ${accountId} flagged for manual review`, 'info');
        btnFlag.disabled = true;
        btnFlag.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
            Flagged
        `;
    });

    btnDownload.addEventListener('click', () => {
        if (!analysisData) return;

        const downloadData = {
            suspicious_accounts: analysisData.suspicious_accounts,
            fraud_rings: analysisData.fraud_rings,
            summary: analysisData.summary,
        };

        const blob = new Blob([JSON.stringify(downloadData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'mulewatch_report.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Report exported successfully', 'success');
    });

    btnReset.addEventListener('click', () => {
        // Reset everything
        if (cy) { cy.destroy(); cy = null; }
        analysisData = null;

        // Hide sections
        graphSection.classList.add('hidden');
        tableSection.classList.add('hidden');
        settingsSection.classList.add('hidden');

        // Show upload overlay
        uploadOverlay.classList.remove('hidden');
        loadingOverlay.classList.add('hidden');

        // Reset metrics
        valTransactions.textContent = 'â€”';
        valRings.textContent = 'â€”';
        valHighRisk.textContent = 'â€”';
        valTime.textContent = 'â€”';

        // Disable buttons
        btnDownload.disabled = true;
        btnReset.disabled = true;
        btnFullReport.classList.add('hidden');

        // Close panel
        closeActionPanel();

        // Reset file input
        fileInput.value = '';

        // Reset nav
        navLinks.forEach(l => l.classList.remove('active'));
        navLinks[0].classList.add('active');

        showToast('Dashboard reset â€” ready for new scan', 'info');
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FULL REPORT POLLING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    btnFullReport.addEventListener('click', () => {
        if (!analysisData || !analysisData.file_id) return;

        btnFullReport.disabled = true;
        // Simple spinner
        btnFullReport.innerHTML = `
            <svg class="spin" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 12a9 9 0 1 1-6.219-8.56" />
            </svg>
            Generating...
        `;

        // Add spin class to css dynamically or just rely on inline SVG animation if needed, 
        // but simple text is fine. Added simple path for spinner.

        pollFullReport(analysisData.file_id).catch(err => {
            showToast('Failed to get full report: ' + err.message, 'error');
            btnFullReport.disabled = false;
            btnFullReport.innerHTML = 'Retry Full Report';
        });
    });

    async function pollFullReport(fileId) {
        let attempts = 0;
        const maxAttempts = 300; // 10 minutes approx

        const check = async () => {
            try {
                const res = await fetch(`/full_report/${fileId}`);
                if (res.status === 202) {
                    attempts++;
                    if (attempts > maxAttempts) throw new Error('Timeout waiting for report');
                    if (attempts % 3 === 0) showToast('Analyzing full dataset... please wait', 'info');
                    setTimeout(check, 2000);
                } else if (res.status === 200) {
                    const fullData = await res.json();
                    analysisData = fullData;
                    // Force clean state
                    analysisData.is_partial = false;
                    renderDashboard();
                    showToast('Full report generated successfully!', 'success');
                } else {
                    const err = await res.json();
                    throw new Error(err.error || 'Unknown error');
                }
            } catch (error) {
                throw error;
            }
        };
        check();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TOAST NOTIFICATIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function showToast(message, type = 'info') {
        toast.classList.remove('hidden', 'show', 'success', 'error', 'info');
        toast.classList.add(type);

        const icons = {
            success: 'âœ“',
            error: 'âœ•',
            info: 'â„¹',
        };

        toast.querySelector('.toast-icon').textContent = icons[type] || 'â„¹';
        toast.querySelector('.toast-text').textContent = message;

        // Force reflow then show
        void toast.offsetWidth;
        toast.classList.add('show');

        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.classList.add('hidden'), 400);
        }, 3500);
    }

})();
